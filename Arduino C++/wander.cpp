// generated by mBlock5 for mBot
// codes make you happy

#include <MeMCore.h>
#include <Arduino.h>
#include <Wire.h>
#include <SoftwareSerial.h>

double currentTime = 0;
double lastTime = 0;
MeLineFollower linefollower_2(2);
MeDCMotor motor_9(9);
MeDCMotor motor_10(10);
MeRGBLed rgbled_7(7, 2);
MeBuzzer buzzer;

float soundDuration = 0;
float silenceDuration = 0;
float currentPitch = 0;
float numberOfBeeps = 0;
float numberOfBlinks = 0;
float redIntensity = 0;
float greenIntensity = 0;
float blueIntensity = 0;
float currentRedIntensity = 0;
float currentGreenIntensity = 0;
float currentBlueIntensity = 0;
float color = 0;
float onDuration = 0;
float offDuration = 0;
float currentSpeed = 0;
float leftRoundness = 0;
float rightRoundness = 0;
float cycle = 0;

double getLastTime(){
  return currentTime = millis() / 1000.0 - lastTime;
}
void move(int direction, int speed) {
  int leftSpeed = 0;
  int rightSpeed = 0;
  if(direction == 1) {
    leftSpeed = speed;
    rightSpeed = speed;
  } else if(direction == 2) {
    leftSpeed = -speed;
    rightSpeed = -speed;
  } else if(direction == 3) {
    leftSpeed = -speed;
    rightSpeed = speed;
  } else if(direction == 4) {
    leftSpeed = speed;
    rightSpeed = -speed;
  }
  motor_9.run((9) == M1 ? -(leftSpeed) : (leftSpeed));
  motor_10.run((10) == M1 ? -(rightSpeed) : (rightSpeed));
}
void Wander(double roundness, double angularity, double speed, double duration, String acceleration, boolean stayInBounds){
  lastTime = millis() / 1000.0;
  if((acceleration == "Constant")  ||  (acceleration == "Falling")){
    currentSpeed = speed;

  }else{
    currentSpeed = 0;

  }
  if((roundness > 0)  &&  (angularity == 0.000000)){
    leftRoundness = 0;
    rightRoundness = roundness;

  }
  cycle = 0;
  while(!(getLastTime() > duration))
  {
    _loop();
    if(stayInBounds){
      if((0 ? (1 == 0 ? linefollower_2.readSensors() == 0 :
      (linefollower_2.readSensors() & 1) == 1) :
      (1 == 0 ? linefollower_2.readSensors() == 3 :
      (linefollower_2.readSensors() & 1) == 0))){

        move(3, 100 / 100.0 * 255);
        _delay(0.5);
        move(3, 0);

      }
      if((0 ? (2 == 0 ? linefollower_2.readSensors() == 0 :
      (linefollower_2.readSensors() & 2) == 2) :
      (2 == 0 ? linefollower_2.readSensors() == 3 :
      (linefollower_2.readSensors() & 2) == 0))){

        move(4, 100 / 100.0 * 255);
        _delay(0.5);
        move(4, 0);

      }

    }
    if(acceleration == "Rising"){
      if(currentSpeed < speed){
        currentSpeed += 0.0125 / duration;

      }

    }
    if(acceleration == "Falling"){
      if(currentSpeed > 0){
        currentSpeed += -0.0125 / duration;

      }

    }
    if((roundness == 0.000000)  &&  (angularity == 0.000000)){

      move(1, currentSpeed / 100.0 * 255);

    }
    if((roundness > 0)  &&  (angularity == 0.000000)){
      MoveRound_N(roundness);

    }
    if((roundness == 0.000000)  &&  (angularity > 0)){
      MoveAngular_N(angularity);

    }

  }
  motor_9.run(0);
  motor_10.run(0);

}
void MoveRound_N(double inputRoundness){
  if(((currentSpeed - leftRoundness) < 0)  ||  ((currentSpeed - rightRoundness) < 0)){

    motor_9.run(-1 * 0/100.0*255);
    motor_10.run(0/100.0*255);

  }else{

    motor_9.run(-1 * (currentSpeed - leftRoundness)/100.0*255);
    motor_10.run((currentSpeed - rightRoundness)/100.0*255);

  }
  if(fmod(cycle, 2) == 0.000000){
    leftRoundness += 0.005;
    rightRoundness += -0.005;

  }else{
    leftRoundness += -0.005;
    rightRoundness += 0.005;

  }
  if((((leftRoundness > inputRoundness)  ||  (leftRoundness == inputRoundness)))  &&  (fmod(cycle, 2) == 0.000000)){
    cycle += 1;

  }
  if((((rightRoundness > inputRoundness)  ||  (rightRoundness == inputRoundness)))  &&  (fmod(cycle, 2) == 1.000000)){
    cycle += 1;

  }

}
void MoveAngular_N(double inputAngularity){
  if(cycle == 0.000000){

    move(3, currentSpeed / 100.0 * 255);
    _delay(inputAngularity / 400);
    move(3, 0);

    move(1, currentSpeed / 100.0 * 255);
    _delay(0.5);
    move(1, 0);
    cycle += 1;

  }
  if((cycle > 0)  &&  (fmod(cycle, 2) == 1.000000)){

    move(4, currentSpeed / 100.0 * 255);
    _delay(inputAngularity / 200);
    move(4, 0);

    move(1, currentSpeed / 100.0 * 255);
    _delay(0.5);
    move(1, 0);

  }else{

    move(3, currentSpeed / 100.0 * 255);
    _delay(inputAngularity / 200);
    move(3, 0);

    move(1, currentSpeed / 100.0 * 255);
    _delay(0.5);
    move(1, 0);

  }
  cycle += 1;

}
void Blink(String temperature, double tempo, double duration, String intensityChange){
  if(temperature == "Warm"){
    color = random(1, 2 +1);
    if(color == 2.000000){
      redIntensity = 255;
      greenIntensity = 0;
      blueIntensity = 0;

    }
    if(color == 1.000000){
      redIntensity = 255;
      greenIntensity = 255;
      blueIntensity = 0;

    }

  }
  if(temperature == "Cool"){
    color = random(1, 2 +1);
    if(color == 2.000000){
      redIntensity = 0;
      greenIntensity = 255;
      blueIntensity = 0;

    }
    if(color == 1.000000){
      redIntensity = 0;
      greenIntensity = 0;
      blueIntensity = 255;

    }

  }
  if(duration * tempo > 1){
    numberOfBlinks = round((duration * tempo));

  }else{
    numberOfBlinks = 1;

  }
  offDuration = (1 / tempo) * 0.5;
  onDuration = ((1 / tempo - offDuration));
  for(int count=0;count<int(numberOfBlinks);count++){
    if(intensityChange == "Constant"){

      rgbled_7.setColor(0, redIntensity, greenIntensity, blueIntensity);
      rgbled_7.show();
      _delay(float(onDuration));

      rgbled_7.setColor(0, 0, 0, 0);
      rgbled_7.show();
      _delay(float(offDuration));

    }
    if(intensityChange == "Rising"){
      currentRedIntensity = 0;
      currentGreenIntensity = 0;
      currentBlueIntensity = 0;
      SmoothTurnOnLights_N(2 * (onDuration / 255));

    }
    if(intensityChange == "Falling"){
      currentRedIntensity = 0;
      currentGreenIntensity = 0;
      currentBlueIntensity = 0;
      SmoothTurnOffLights_N(2 * (onDuration / 255));

    }
    if(intensityChange == "Rising-Falling"){
      currentRedIntensity = 0;
      currentGreenIntensity = 0;
      currentBlueIntensity = 0;
      SmoothTurnOnLights_N(onDuration / 255);
      SmoothTurnOffLights_N(onDuration / 255);

    }
    if(intensityChange == "Falling-Rising"){
      currentRedIntensity = 0;
      currentGreenIntensity = 0;
      currentBlueIntensity = 0;
      SmoothTurnOffLights_N(onDuration / 255);
      SmoothTurnOnLights_N(onDuration / 255);

    }
  }

}
void SmoothTurnOnLights_N(double stepDuration){
  while(!((currentRedIntensity == redIntensity)  &&  ((currentGreenIntensity == greenIntensity)  &&  (currentBlueIntensity == blueIntensity))))
  {
    _loop();

    rgbled_7.setColor(0, currentRedIntensity, currentGreenIntensity, currentBlueIntensity);
    rgbled_7.show();
    if(!((currentRedIntensity == redIntensity))){
      currentRedIntensity += 1;

    }
    if(!((currentGreenIntensity == greenIntensity))){
      currentGreenIntensity += 1;

    }
    if(!((currentBlueIntensity == blueIntensity))){
      currentBlueIntensity += 1;

    }
    _delay(float(stepDuration));

  }

}
void SmoothTurnOffLights_N(double stepDuration){
  while(!((currentRedIntensity == 0.000000)  &&  ((currentGreenIntensity == 0.000000)  &&  (currentBlueIntensity == 0.000000))))
  {
    _loop();

    rgbled_7.setColor(0, currentRedIntensity, currentGreenIntensity, currentBlueIntensity);
    rgbled_7.show();
    if(!((currentRedIntensity == 0.000000))){
      currentRedIntensity += -1;

    }
    if(!((currentGreenIntensity == 0.000000))){
      currentGreenIntensity += -1;

    }
    if(!((currentBlueIntensity == 0.000000))){
      currentBlueIntensity += -1;

    }
    _delay(float(stepDuration));

  }

  rgbled_7.setColor(0, 0, 0, 0);
  rgbled_7.show();

}
void Beep(double pitch, double tempo, double duration, String intonation){
  if(duration * tempo > 1){
    numberOfBeeps = round((duration * tempo));

  }else{
    numberOfBeeps = 1;

  }
  silenceDuration = (1 / tempo) * 0.5;
  soundDuration = ((1 / tempo - silenceDuration));
  for(int count8=0;count8<int(numberOfBeeps);count8++){
    if(intonation == "Constant"){

      buzzer.tone(pitch, soundDuration * 1000);
      _delay(float(silenceDuration));

    }
    if(intonation == "Rising"){
      currentPitch = ((pitch - 100));
      for(int count2=0;count2<400;count2++){

        buzzer.tone(currentPitch, soundDuration / 200 * 1000);
        currentPitch = (currentPitch + 0.5);
      }

    }
    if(intonation == "Falling"){
      currentPitch = (pitch + 100);
      for(int count3=0;count3<400;count3++){

        buzzer.tone(currentPitch, soundDuration / 200 * 1000);
        currentPitch = ((currentPitch - 0.5));
      }

    }
    if(intonation == "Rising-Falling"){
      currentPitch = ((pitch - 100));
      for(int count4=0;count4<400;count4++){

        buzzer.tone(currentPitch, soundDuration / 400 * 1000);
        currentPitch = (currentPitch + 0.5);
      }
      for(int count5=0;count5<400;count5++){

        buzzer.tone(currentPitch, soundDuration / 400 * 1000);
        currentPitch = ((currentPitch - 0.5));
      }

    }
    if(intonation == "Falling-Rising"){
      currentPitch = (pitch + 100);
      for(int count6=0;count6<400;count6++){

        buzzer.tone(currentPitch, soundDuration / 400 * 1000);
        currentPitch = ((currentPitch - 0.5));
      }
      for(int count7=0;count7<400;count7++){

        buzzer.tone(currentPitch, soundDuration / 400 * 1000);
        currentPitch = (currentPitch + 0.5);
      }

    }
  }

}

void _delay(float seconds) {
  long endTime = millis() + seconds * 1000;
  while(millis() < endTime) _loop();
}

void setup() {
  rgbled_7.fillPixelsBak(0, 2, 1);

  // Wander(roundness, angularity, speed, duration, acceleration, stayInBounds)
//   Wander(50, 0, 100, 10, "Rising", false);

  // Blink(temperature, tempo, duration, intensityChange)
//   Blink("Warm", 2, 5, "Constant");
//   Blink("Cool", 0.5, 2, "Rising-Falling");

  // // Beep(pitch, tempo, duration, intonation)
  Beep(300, 2, 5, "Rising");
  Beep(500, 1, 5, "Constant");
  Beep(700, 0.5, 5, "Falling");
}

void _loop() {
}

void loop() {
  _loop();
}

